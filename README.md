# matplotlib_API
Реализовать API, которое позволяет генерировать, преобразовывать и визуализировать последовательность плоских полигонов, представленных в виде картежа картежей (например: ((0,0), (0,1), (1,1), (1,0)) — представление для квадрата). Последовательности представлений полигонов представляют собой итераторы (далее: последовательности полигонов). Решать задачи с использованием функционального стиля программирования, в том числе активно использовать функции из модуля itertools и functools.
1) Реализовать функцию визуализации последовательности полигонов, представленной в виде итератора (например, можно использовать визуализацию с помощью библиотеки matplotlib)
2)  Реализовать функции, генерирующие бесконечную последовательность непересекающихся полигонов с различающимися координатами (например, «ленту»):
а)  прямоугольников (gen_rectangle);
б) треугольников (gen_triangle);
в) правильных шестиугольников (gen_hexagon).
С помощью данных функций используя функции из модуля itertools сгенерировать семь фигур, включающих как прямоугольники, так и треугольники и шестиугольники, визуализировать результат.
3)Реализовать операции:
а) параллельный перенос (tr_translate);
б) поворот (tr_rotate);
в) симметрия (tr_symmetry);
г) гомотетия (tr_homothety);
Которые можно применить к последовательности полигонов с помощью функции map.
4) С помощью данных функций создать и визуализировать (рис. 3):
а) три параллельных «ленты» из последовательностей полигонов, расположенных под острым углом к оси абсцисс;
б) две пересекающихся «ленты» из последовательностей полигонов, пересекающихся не в начале координат;
в) две параллельных ленты треугольников, ориентированных симметрично друг к другу;
г) последовательность четырехугольников в разном масштабе, ограниченных двумя прямыми, пересекающимися в начале координат.
5) Реализовать операции:
а) фильтрации фигур, являющихся выпуклыми многоугольниками (flt_convex_polygon);
б) фильтрации фигур, имеющих хотя бы один угол, совпадающий с заданной точкой (flt_angle_point);
в) фильтрации фигур, имеющих площадь меньше заданной (flt_square);
г) фильтрации фигур, имеющих кратчайшую сторону меньше заданного значения (flt_short_side);
д) фильтрации выпуклых многоугольников, включающих заданную точку (внутри многоугольника) (flt_point_inside);
е) фильтрации выпуклых многоугольников, включающих любой из углов заданного многоугольника (flt_polygon_angles_inside);
Которые можно применить к последовательности полигонов с помощью функции filter.
6)С помощью данных функций реализовать и визуализировать:
а) фильтрацию фигур, созданных в рамках пункта 4.4; подобрать параметры так, чтобы на выходе было получено шесть фигур;
б) используя функции генерации из п. 2 и операции из п. 3, создать не менее 15 фигур, которые имеют различный масштаб, и выбрать из них (подбором параметра фильтрации) не более четырех фигур, имеющих кратчайшую сторону меньше заданного значения;
в) используя функции генерации из п. 2 и операции из п. 3, создать не менее 15 фигур имеющих множество пересечений и обеспечить фильтрацию пересекающихся фигур.
7) Реализовать декораторы и продемонстрировать корректность их работы:
а) фильтрующие многоугольники в итераторах среди аргументов функции, работающие на основе функций из п. 5: @flt_convex_polygon, @flt_angle_point, @flt_square, @flt_short_side, @flt_point_inside, @flt_polygon_angles_inside;
б)преобразующие многоугольники в итераторах среди аргументов функции, работающие на основе функций из п. 3: @tr_translate, @tr_rotate, @tr_symmetry, @tr_homothety.
8) Реализовать функции и продемонстрировать их корректность:
а) поиск угла, самого близкого к началу координат (agr_origin_nearest);
б)  поиск самого длинной стороны многоугольника (agr_max_side);
в) поиск самой маленькой площади многоугольника (agr_min_area);
г) расчет суммарного периметра (agr_perimeter);
д)  расчет суммарной площади (agr_area);
Которые можно применить к последовательности полигонов с помощью функции functools.reduce.
9)Реализовать функции и продемонстрировать пример их работы (если возможно, с визуализацией):
а) склейки полигонов в одну последовательность полигонов из нескольких последовательностей полигонов zip_polygons(iterator1, iterator2, [iterator3, ...]). Пример:
zip_polygons([((1, 1), (2, 2), (3, 1)), ((11, 11), (12, 12), (13, 11))], [((1, -1), (2, -2), (3, -1)), ((11, -11), (12, -12), (13, -11))]) → [((1, 1), (2, 2), (3, 1), (1, -1), (2, -2), (3, -1)), ((11, 11), (12, 12), (13, 11), (11, -11), (12, -12), (13, -11))].
б) генерации count_2D() параметры: (start1, start2), [(step1, step2)], результаты: (start1, start2), (start1+step1, start2+step2), (start1+2*step1, start2+2*step2);
в) склейки полигонов в одну последовательность полигонов из нескольких последовательностей zip_tuple(iterator1, iterator2). Пример:
zip_tuple([(1,1), (2,2), (3,3), (4,4)], [(2,2), (3,3), (4,4), (5,5)], [(3,3), (4,4), (5,5), (6,6)]) → ((1,1), (2,2), (3,3)), ((2,2), (3,3) (4,4)), ((3,3), (4,4), (5,5)), ((5,5), (6,6), (7,7)).
